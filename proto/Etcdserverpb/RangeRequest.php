<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: rpc.proto

namespace Etcdserverpb;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Protobuf type <code>etcdserverpb.RangeRequest</code>
 */
class RangeRequest extends \Google\Protobuf\Internal\Message
{
    /**
     * <pre>
     * key is the first key for the range. If range_end is not given, the request only looks up key.
     * </pre>
     *
     * <code>bytes key = 1;</code>
     */
    private $key = '';
    /**
     * <pre>
     * range_end is the upper bound on the requested range [key, range_end).
     * If range_end is '&#92;0', the range is all keys &gt;= key.
     * If range_end is key plus one (e.g., "aa"+1 == "ab", "a&#92;xff"+1 == "b"),
     * then the range request gets all keys prefixed with key.
     * If both key and range_end are '&#92;0', then the range request returns all keys.
     * </pre>
     *
     * <code>bytes range_end = 2;</code>
     */
    private $range_end = '';
    /**
     * <pre>
     * limit is a limit on the number of keys returned for the request.
     * </pre>
     *
     * <code>int64 limit = 3;</code>
     */
    private $limit = 0;
    /**
     * <pre>
     * revision is the point-in-time of the key-value store to use for the range.
     * If revision is less or equal to zero, the range is over the newest key-value store.
     * If the revision has been compacted, ErrCompacted is returned as a response.
     * </pre>
     *
     * <code>int64 revision = 4;</code>
     */
    private $revision = 0;
    /**
     * <pre>
     * sort_order is the order for returned sorted results.
     * </pre>
     *
     * <code>.etcdserverpb.RangeRequest.SortOrder sort_order = 5;</code>
     */
    private $sort_order = 0;
    /**
     * <pre>
     * sort_target is the key-value field to use for sorting.
     * </pre>
     *
     * <code>.etcdserverpb.RangeRequest.SortTarget sort_target = 6;</code>
     */
    private $sort_target = 0;
    /**
     * <pre>
     * serializable sets the range request to use serializable member-local reads.
     * Range requests are linearizable by default; linearizable requests have higher
     * latency and lower throughput than serializable requests but reflect the current
     * consensus of the cluster. For better performance, in exchange for possible stale reads,
     * a serializable range request is served locally without needing to reach consensus
     * with other nodes in the cluster.
     * </pre>
     *
     * <code>bool serializable = 7;</code>
     */
    private $serializable = false;
    /**
     * <pre>
     * keys_only when set returns only the keys and not the values.
     * </pre>
     *
     * <code>bool keys_only = 8;</code>
     */
    private $keys_only = false;
    /**
     * <pre>
     * count_only when set returns only the count of the keys in the range.
     * </pre>
     *
     * <code>bool count_only = 9;</code>
     */
    private $count_only = false;
    /**
     * <pre>
     * min_mod_revision is the lower bound for returned key mod revisions; all keys with
     * lesser mod revisions will be filtered away.
     * </pre>
     *
     * <code>int64 min_mod_revision = 10;</code>
     */
    private $min_mod_revision = 0;
    /**
     * <pre>
     * max_mod_revision is the upper bound for returned key mod revisions; all keys with
     * greater mod revisions will be filtered away.
     * </pre>
     *
     * <code>int64 max_mod_revision = 11;</code>
     */
    private $max_mod_revision = 0;
    /**
     * <pre>
     * min_create_revision is the lower bound for returned key create revisions; all keys with
     * lesser create trevisions will be filtered away.
     * </pre>
     *
     * <code>int64 min_create_revision = 12;</code>
     */
    private $min_create_revision = 0;
    /**
     * <pre>
     * max_create_revision is the upper bound for returned key create revisions; all keys with
     * greater create revisions will be filtered away.
     * </pre>
     *
     * <code>int64 max_create_revision = 13;</code>
     */
    private $max_create_revision = 0;

    public function __construct() {
        \GPBMetadata\Rpc::initOnce();
        parent::__construct();
    }

    /**
     * <pre>
     * key is the first key for the range. If range_end is not given, the request only looks up key.
     * </pre>
     *
     * <code>bytes key = 1;</code>
     */
    public function getKey()
    {
        return $this->key;
    }

    /**
     * <pre>
     * key is the first key for the range. If range_end is not given, the request only looks up key.
     * </pre>
     *
     * <code>bytes key = 1;</code>
     */
    public function setKey($var)
    {
        GPBUtil::checkString($var, False);
        $this->key = $var;
    }

    /**
     * <pre>
     * range_end is the upper bound on the requested range [key, range_end).
     * If range_end is '&#92;0', the range is all keys &gt;= key.
     * If range_end is key plus one (e.g., "aa"+1 == "ab", "a&#92;xff"+1 == "b"),
     * then the range request gets all keys prefixed with key.
     * If both key and range_end are '&#92;0', then the range request returns all keys.
     * </pre>
     *
     * <code>bytes range_end = 2;</code>
     */
    public function getRangeEnd()
    {
        return $this->range_end;
    }

    /**
     * <pre>
     * range_end is the upper bound on the requested range [key, range_end).
     * If range_end is '&#92;0', the range is all keys &gt;= key.
     * If range_end is key plus one (e.g., "aa"+1 == "ab", "a&#92;xff"+1 == "b"),
     * then the range request gets all keys prefixed with key.
     * If both key and range_end are '&#92;0', then the range request returns all keys.
     * </pre>
     *
     * <code>bytes range_end = 2;</code>
     */
    public function setRangeEnd($var)
    {
        GPBUtil::checkString($var, False);
        $this->range_end = $var;
    }

    /**
     * <pre>
     * limit is a limit on the number of keys returned for the request.
     * </pre>
     *
     * <code>int64 limit = 3;</code>
     */
    public function getLimit()
    {
        return $this->limit;
    }

    /**
     * <pre>
     * limit is a limit on the number of keys returned for the request.
     * </pre>
     *
     * <code>int64 limit = 3;</code>
     */
    public function setLimit($var)
    {
        GPBUtil::checkInt64($var);
        $this->limit = $var;
    }

    /**
     * <pre>
     * revision is the point-in-time of the key-value store to use for the range.
     * If revision is less or equal to zero, the range is over the newest key-value store.
     * If the revision has been compacted, ErrCompacted is returned as a response.
     * </pre>
     *
     * <code>int64 revision = 4;</code>
     */
    public function getRevision()
    {
        return $this->revision;
    }

    /**
     * <pre>
     * revision is the point-in-time of the key-value store to use for the range.
     * If revision is less or equal to zero, the range is over the newest key-value store.
     * If the revision has been compacted, ErrCompacted is returned as a response.
     * </pre>
     *
     * <code>int64 revision = 4;</code>
     */
    public function setRevision($var)
    {
        GPBUtil::checkInt64($var);
        $this->revision = $var;
    }

    /**
     * <pre>
     * sort_order is the order for returned sorted results.
     * </pre>
     *
     * <code>.etcdserverpb.RangeRequest.SortOrder sort_order = 5;</code>
     */
    public function getSortOrder()
    {
        return $this->sort_order;
    }

    /**
     * <pre>
     * sort_order is the order for returned sorted results.
     * </pre>
     *
     * <code>.etcdserverpb.RangeRequest.SortOrder sort_order = 5;</code>
     */
    public function setSortOrder($var)
    {
        GPBUtil::checkEnum($var, \Etcdserverpb\RangeRequest_SortOrder::class);
        $this->sort_order = $var;
    }

    /**
     * <pre>
     * sort_target is the key-value field to use for sorting.
     * </pre>
     *
     * <code>.etcdserverpb.RangeRequest.SortTarget sort_target = 6;</code>
     */
    public function getSortTarget()
    {
        return $this->sort_target;
    }

    /**
     * <pre>
     * sort_target is the key-value field to use for sorting.
     * </pre>
     *
     * <code>.etcdserverpb.RangeRequest.SortTarget sort_target = 6;</code>
     */
    public function setSortTarget($var)
    {
        GPBUtil::checkEnum($var, \Etcdserverpb\RangeRequest_SortTarget::class);
        $this->sort_target = $var;
    }

    /**
     * <pre>
     * serializable sets the range request to use serializable member-local reads.
     * Range requests are linearizable by default; linearizable requests have higher
     * latency and lower throughput than serializable requests but reflect the current
     * consensus of the cluster. For better performance, in exchange for possible stale reads,
     * a serializable range request is served locally without needing to reach consensus
     * with other nodes in the cluster.
     * </pre>
     *
     * <code>bool serializable = 7;</code>
     */
    public function getSerializable()
    {
        return $this->serializable;
    }

    /**
     * <pre>
     * serializable sets the range request to use serializable member-local reads.
     * Range requests are linearizable by default; linearizable requests have higher
     * latency and lower throughput than serializable requests but reflect the current
     * consensus of the cluster. For better performance, in exchange for possible stale reads,
     * a serializable range request is served locally without needing to reach consensus
     * with other nodes in the cluster.
     * </pre>
     *
     * <code>bool serializable = 7;</code>
     */
    public function setSerializable($var)
    {
        GPBUtil::checkBool($var);
        $this->serializable = $var;
    }

    /**
     * <pre>
     * keys_only when set returns only the keys and not the values.
     * </pre>
     *
     * <code>bool keys_only = 8;</code>
     */
    public function getKeysOnly()
    {
        return $this->keys_only;
    }

    /**
     * <pre>
     * keys_only when set returns only the keys and not the values.
     * </pre>
     *
     * <code>bool keys_only = 8;</code>
     */
    public function setKeysOnly($var)
    {
        GPBUtil::checkBool($var);
        $this->keys_only = $var;
    }

    /**
     * <pre>
     * count_only when set returns only the count of the keys in the range.
     * </pre>
     *
     * <code>bool count_only = 9;</code>
     */
    public function getCountOnly()
    {
        return $this->count_only;
    }

    /**
     * <pre>
     * count_only when set returns only the count of the keys in the range.
     * </pre>
     *
     * <code>bool count_only = 9;</code>
     */
    public function setCountOnly($var)
    {
        GPBUtil::checkBool($var);
        $this->count_only = $var;
    }

    /**
     * <pre>
     * min_mod_revision is the lower bound for returned key mod revisions; all keys with
     * lesser mod revisions will be filtered away.
     * </pre>
     *
     * <code>int64 min_mod_revision = 10;</code>
     */
    public function getMinModRevision()
    {
        return $this->min_mod_revision;
    }

    /**
     * <pre>
     * min_mod_revision is the lower bound for returned key mod revisions; all keys with
     * lesser mod revisions will be filtered away.
     * </pre>
     *
     * <code>int64 min_mod_revision = 10;</code>
     */
    public function setMinModRevision($var)
    {
        GPBUtil::checkInt64($var);
        $this->min_mod_revision = $var;
    }

    /**
     * <pre>
     * max_mod_revision is the upper bound for returned key mod revisions; all keys with
     * greater mod revisions will be filtered away.
     * </pre>
     *
     * <code>int64 max_mod_revision = 11;</code>
     */
    public function getMaxModRevision()
    {
        return $this->max_mod_revision;
    }

    /**
     * <pre>
     * max_mod_revision is the upper bound for returned key mod revisions; all keys with
     * greater mod revisions will be filtered away.
     * </pre>
     *
     * <code>int64 max_mod_revision = 11;</code>
     */
    public function setMaxModRevision($var)
    {
        GPBUtil::checkInt64($var);
        $this->max_mod_revision = $var;
    }

    /**
     * <pre>
     * min_create_revision is the lower bound for returned key create revisions; all keys with
     * lesser create trevisions will be filtered away.
     * </pre>
     *
     * <code>int64 min_create_revision = 12;</code>
     */
    public function getMinCreateRevision()
    {
        return $this->min_create_revision;
    }

    /**
     * <pre>
     * min_create_revision is the lower bound for returned key create revisions; all keys with
     * lesser create trevisions will be filtered away.
     * </pre>
     *
     * <code>int64 min_create_revision = 12;</code>
     */
    public function setMinCreateRevision($var)
    {
        GPBUtil::checkInt64($var);
        $this->min_create_revision = $var;
    }

    /**
     * <pre>
     * max_create_revision is the upper bound for returned key create revisions; all keys with
     * greater create revisions will be filtered away.
     * </pre>
     *
     * <code>int64 max_create_revision = 13;</code>
     */
    public function getMaxCreateRevision()
    {
        return $this->max_create_revision;
    }

    /**
     * <pre>
     * max_create_revision is the upper bound for returned key create revisions; all keys with
     * greater create revisions will be filtered away.
     * </pre>
     *
     * <code>int64 max_create_revision = 13;</code>
     */
    public function setMaxCreateRevision($var)
    {
        GPBUtil::checkInt64($var);
        $this->max_create_revision = $var;
    }

}

